; generated by ARM/Thumb C/C++ Compiler with , RVCT3.1 [Build 939] for uVision
; commandline ArmCC [--debug -c --asm --interleave -oglobal_adc_init.o --depend=global_adc_init.d --device=DARMP --apcs=interwork -O0 -I"C:\Program Files\Keil\ARM\INC\Philips" --omf_browse=global_adc_init.crf global_adc_init.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  init_adc PROC
;;;20     	// activarea functiei ADC pentru pini (ADC1)
;;;21     	PINSEL0 |= ((1<<24) | (1<<25) | (1<<26) | (1<<27));
000000  e59f031c          LDR      r0,|L1.804|
000004  e5900000          LDR      r0,[r0,#0]
000008  e380040f          ORR      r0,r0,#0xf000000
00000c  e59f1310          LDR      r1,|L1.804|
000010  e5810000          STR      r0,[r1,#0]
;;;22         // activarea functiei ADC pentru pini (ADC0)
;;;23     	PINSEL1 |= ((1<<11) | (1<<12) | (1<<24));
000014  e1a00001          MOV      r0,r1
000018  e5900004          LDR      r0,[r0,#4]
00001c  e3800401          ORR      r0,r0,#0x1000000
000020  e3800b06          ORR      r0,r0,#0x1800
000024  e5810004          STR      r0,[r1,#4]
;;;24     	PINSEL1 &=~((1<<10) | (1<<13) | (1<<25));
000028  e1a00001          MOV      r0,r1
00002c  e5900004          LDR      r0,[r0,#4]
000030  e3c00402          BIC      r0,r0,#0x2000000
000034  e3c00b09          BIC      r0,r0,#0x2400
000038  e5810004          STR      r0,[r1,#4]
;;;25     	// power control pentru periferice
;;;26     	PCONP |= ((1<<12)|(1<<20)); // activare power ADC1/0
00003c  e281081d          ADD      r0,r1,#0x1d0000
000040  e59000c4          LDR      r0,[r0,#0xc4]
000044  e3800601          ORR      r0,r0,#0x100000
000048  e3800a01          ORR      r0,r0,#0x1000
00004c  e281181d          ADD      r1,r1,#0x1d0000
000050  e58100c4          STR      r0,[r1,#0xc4]
;;;27     	// resetare conversii si biti de control
;;;28     	AD0CR = 0x0;	// reg control ADC0
000054  e3a00000          MOV      r0,#0
000058  e2411972          SUB      r1,r1,#0x1c8000
00005c  e5810000          STR      r0,[r1,#0]
;;;29     	AD1CR = 0x0;	// reg control ADC1
000060  e281190b          ADD      r1,r1,#0x2c000
000064  e5810000          STR      r0,[r1,#0]
;;;30     	// setare clock conversie CLKDIV fct de VPB CLK
;;;31     	// aici se considera 6 factor de divizare la 30Mhz
;;;32     	// freccventa MCU 30/(6+1) = 4.2MHz <= 4.5MHz (impus)
;;;33     	AD0CR |=((1<<9) | (1<<10));
000068  e241090b          SUB      r0,r1,#0x2c000
00006c  e5900000          LDR      r0,[r0,#0]
000070  e3800c06          ORR      r0,r0,#0x600
000074  e241190b          SUB      r1,r1,#0x2c000
000078  e5810000          STR      r0,[r1,#0]
;;;34     	AD1CR |=((1<<9) | (1<<10));
00007c  e281090b          ADD      r0,r1,#0x2c000
000080  e5900000          LDR      r0,[r0,#0]
000084  e3800c06          ORR      r0,r0,#0x600
000088  e281190b          ADD      r1,r1,#0x2c000
00008c  e5810000          STR      r0,[r1,#0]
;;;35     	// dezactivare mod BURST, operare in mod controlat software
;;;36     	AD0CR &=~(1<<16);
000090  e241090b          SUB      r0,r1,#0x2c000
000094  e5900000          LDR      r0,[r0,#0]
000098  e3c00801          BIC      r0,r0,#0x10000
00009c  e241190b          SUB      r1,r1,#0x2c000
0000a0  e5810000          STR      r0,[r1,#0]
;;;37     	AD1CR &=~(1<<16);
0000a4  e281090b          ADD      r0,r1,#0x2c000
0000a8  e5900000          LDR      r0,[r0,#0]
0000ac  e3c00801          BIC      r0,r0,#0x10000
0000b0  e281190b          ADD      r1,r1,#0x2c000
0000b4  e5810000          STR      r0,[r1,#0]
;;;38     }
0000b8  e12fff1e          BX       lr
;;;39     
                          ENDP

                  read_adc0 PROC
;;;41     unsigned int read_adc0(unsigned char channel)
;;;42     {
0000bc  e52de004          PUSH     {lr}
0000c0  e1a02000          MOV      r2,r0
;;;43        // rezultatul conversiei
;;;44        unsigned int i;
;;;45        // initializare adc
;;;46        init_adc();
0000c4  ebfffffe          BL       init_adc
;;;47        // opreste conversiile anterioare si reseteaza canalele
;;;48        AD0CR &= ~((1<<24) | (1<<25) | (1<<26));
0000c8  e59f0258          LDR      r0,|L1.808|
0000cc  e5900000          LDR      r0,[r0,#0]
0000d0  e3c00407          BIC      r0,r0,#0x7000000
0000d4  e59f124c          LDR      r1,|L1.808|
0000d8  e5810000          STR      r0,[r1,#0]
;;;49        // selecteaza canalul primit la intrare
;;;50        AD0CR |= (1<<channel);
0000dc  e1a00001          MOV      r0,r1
0000e0  e5900000          LDR      r0,[r0,#0]
0000e4  e3a01001          MOV      r1,#1
0000e8  e1800211          ORR      r0,r0,r1,LSL r2
0000ec  e59f1234          LDR      r1,|L1.808|
0000f0  e5810000          STR      r0,[r1,#0]
;;;51        // seteaza ADC0 operational; bit PDN=1
;;;52        AD0CR |= (1<<21); 
0000f4  e1a00001          MOV      r0,r1
0000f8  e5900000          LDR      r0,[r0,#0]
0000fc  e3800602          ORR      r0,r0,#0x200000
000100  e5810000          STR      r0,[r1,#0]
;;;53        // start conversie
;;;54        AD0CR |= (1<<24);
000104  e1a00001          MOV      r0,r1
000108  e5900000          LDR      r0,[r0,#0]
00010c  e3800401          ORR      r0,r0,#0x1000000
000110  e5810000          STR      r0,[r1,#0]
;;;55        do
000114  e1a00000          MOV      r0,r0
                  |L1.280|
;;;56        {
;;;57        switch(channel)	 // determina canalul 
000118  e3520008          CMP      r2,#8
00011c  308ff102          ADDCC    pc,pc,r2,LSL #2
000120  ea000027          B        |L1.452|
000124  ea000006          B        |L1.324|
000128  ea000009          B        |L1.340|
00012c  ea00000c          B        |L1.356|
000130  ea00000f          B        |L1.372|
000134  ea000012          B        |L1.388|
000138  ea000015          B        |L1.404|
00013c  ea000018          B        |L1.420|
000140  ea00001b          B        |L1.436|
                  |L1.324|
;;;58        {
;;;59        case 0:
000144  e1a00000          MOV      r0,r0
;;;60     		   i=AD0DR0; // preia valoarea din reg de date canal 0
000148  e59f01d8          LDR      r0,|L1.808|
00014c  e5903010          LDR      r3,[r0,#0x10]
;;;61     		   break;
000150  ea00001d          B        |L1.460|
                  |L1.340|
;;;62        case 1:
000154  e1a00000          MOV      r0,r0
;;;63     		   i=AD0DR1; // preia valoarea din reg de date canal 1
000158  e59f01c8          LDR      r0,|L1.808|
00015c  e5903014          LDR      r3,[r0,#0x14]
;;;64     		   break;
000160  ea000019          B        |L1.460|
                  |L1.356|
;;;65        case 2:
000164  e1a00000          MOV      r0,r0
;;;66     		   i=AD0DR2; // preia valoarea din reg de date canal 2
000168  e59f01b8          LDR      r0,|L1.808|
00016c  e5903018          LDR      r3,[r0,#0x18]
;;;67     		   break;
000170  ea000015          B        |L1.460|
                  |L1.372|
;;;68        case 3:
000174  e1a00000          MOV      r0,r0
;;;69     		   i=AD0DR3; // preia valoarea din reg de date canal 3
000178  e59f01a8          LDR      r0,|L1.808|
00017c  e590301c          LDR      r3,[r0,#0x1c]
;;;70     		   break;
000180  ea000011          B        |L1.460|
                  |L1.388|
;;;71        case 4:
000184  e1a00000          MOV      r0,r0
;;;72     		   i=AD0DR4; // preia valoarea din reg de date canal 4
000188  e59f0198          LDR      r0,|L1.808|
00018c  e5903020          LDR      r3,[r0,#0x20]
;;;73     		   break;
000190  ea00000d          B        |L1.460|
                  |L1.404|
;;;74        case 5:
000194  e1a00000          MOV      r0,r0
;;;75     		   i=AD0DR5; // preia valoarea din reg de date canal 5
000198  e59f0188          LDR      r0,|L1.808|
00019c  e5903024          LDR      r3,[r0,#0x24]
;;;76     		   break;
0001a0  ea000009          B        |L1.460|
                  |L1.420|
;;;77        case 6:
0001a4  e1a00000          MOV      r0,r0
;;;78     		   i=AD0DR6; // preia valoarea din reg de date canal 6
0001a8  e59f0178          LDR      r0,|L1.808|
0001ac  e5903028          LDR      r3,[r0,#0x28]
;;;79     		   break;
0001b0  ea000005          B        |L1.460|
                  |L1.436|
;;;80        case 7:
0001b4  e1a00000          MOV      r0,r0
;;;81     		   i=AD0DR7; // preia valoarea din reg de date canal 7
0001b8  e59f0168          LDR      r0,|L1.808|
0001bc  e590302c          LDR      r3,[r0,#0x2c]
;;;82     		   break;
0001c0  ea000001          B        |L1.460|
                  |L1.452|
;;;83        default:
0001c4  e1a00000          MOV      r0,r0
;;;84        		   break;
0001c8  e1a00000          MOV      r0,r0
                  |L1.460|
0001cc  e1a00000          MOV      r0,r0                 ;61
;;;85        } //end switch
;;;86        } 
;;;87        //asteapta final conversie(bit DONE=1 in reg global de date)
;;;88        while ((AD0GDR & 0x80000000) == 0); 
0001d0  e59f0150          LDR      r0,|L1.808|
0001d4  e5900004          LDR      r0,[r0,#4]
0001d8  e3100102          TST      r0,#0x80000000
0001dc  0affffcd          BEQ      |L1.280|
;;;89        // izoleaza rezultatul si revine
;;;90        return ((i >> 6) & 0x03FF);		    
0001e0  e59f0144          LDR      r0,|L1.812|
0001e4  e0000323          AND      r0,r0,r3,LSR #6
0001e8  e49de004          POP      {lr}
;;;91     }
0001ec  e12fff1e          BX       lr
;;;92     
                          ENDP

                  read_adc1 PROC
;;;93     unsigned int read_adc1(unsigned char channel)
;;;94     {
0001f0  e52de004          PUSH     {lr}
0001f4  e1a02000          MOV      r2,r0
;;;95     // rezultatul conversiei
;;;96        unsigned int i;
;;;97        // initializare adc
;;;98        init_adc();
0001f8  ebfffffe          BL       init_adc
;;;99        // opreste conversiile anterioare si reseteaza canalele
;;;100       AD1CR &= ~((1<<24) | (1<<25) | (1<<26));
0001fc  e59f012c          LDR      r0,|L1.816|
000200  e5900000          LDR      r0,[r0,#0]
000204  e3c00407          BIC      r0,r0,#0x7000000
000208  e59f1120          LDR      r1,|L1.816|
00020c  e5810000          STR      r0,[r1,#0]
;;;101       // selecteaza canalul primit la intrare
;;;102       AD1CR |= (1<<channel);
000210  e1a00001          MOV      r0,r1
000214  e5900000          LDR      r0,[r0,#0]
000218  e3a01001          MOV      r1,#1
00021c  e1800211          ORR      r0,r0,r1,LSL r2
000220  e59f1108          LDR      r1,|L1.816|
000224  e5810000          STR      r0,[r1,#0]
;;;103       // seteaza ADC1 operational; bit PDN=1
;;;104       AD1CR |= (1<<21); 
000228  e1a00001          MOV      r0,r1
00022c  e5900000          LDR      r0,[r0,#0]
000230  e3800602          ORR      r0,r0,#0x200000
000234  e5810000          STR      r0,[r1,#0]
;;;105       // start conversie
;;;106       AD1CR |= (1<<24);
000238  e1a00001          MOV      r0,r1
00023c  e5900000          LDR      r0,[r0,#0]
000240  e3800401          ORR      r0,r0,#0x1000000
000244  e5810000          STR      r0,[r1,#0]
;;;107       do
000248  e1a00000          MOV      r0,r0
                  |L1.588|
;;;108       {
;;;109       switch(channel)	 // determina canalul 
00024c  e3520008          CMP      r2,#8
000250  308ff102          ADDCC    pc,pc,r2,LSL #2
000254  ea000027          B        |L1.760|
000258  ea000006          B        |L1.632|
00025c  ea000009          B        |L1.648|
000260  ea00000c          B        |L1.664|
000264  ea00000f          B        |L1.680|
000268  ea000012          B        |L1.696|
00026c  ea000015          B        |L1.712|
000270  ea000018          B        |L1.728|
000274  ea00001b          B        |L1.744|
                  |L1.632|
;;;110       {
;;;111       case 0:
000278  e1a00000          MOV      r0,r0
;;;112    		   i=AD1DR0; // preia valoarea din reg de date canal 0
00027c  e59f00ac          LDR      r0,|L1.816|
000280  e5903010          LDR      r3,[r0,#0x10]
;;;113    		   break;
000284  ea00001d          B        |L1.768|
                  |L1.648|
;;;114       case 1:
000288  e1a00000          MOV      r0,r0
;;;115    		   i=AD1DR1; // preia valoarea din reg de date canal 1
00028c  e59f009c          LDR      r0,|L1.816|
000290  e5903014          LDR      r3,[r0,#0x14]
;;;116    		   break;
000294  ea000019          B        |L1.768|
                  |L1.664|
;;;117       case 2:
000298  e1a00000          MOV      r0,r0
;;;118    		   i=AD1DR2; // preia valoarea din reg de date canal 2
00029c  e59f008c          LDR      r0,|L1.816|
0002a0  e5903018          LDR      r3,[r0,#0x18]
;;;119    		   break;
0002a4  ea000015          B        |L1.768|
                  |L1.680|
;;;120       case 3:
0002a8  e1a00000          MOV      r0,r0
;;;121    		   i=AD1DR3; // preia valoarea din reg de date canal 3
0002ac  e59f007c          LDR      r0,|L1.816|
0002b0  e590301c          LDR      r3,[r0,#0x1c]
;;;122    		   break;
0002b4  ea000011          B        |L1.768|
                  |L1.696|
;;;123       case 4:
0002b8  e1a00000          MOV      r0,r0
;;;124    		   i=AD1DR4; // preia valoarea din reg de date canal 4
0002bc  e59f006c          LDR      r0,|L1.816|
0002c0  e5903020          LDR      r3,[r0,#0x20]
;;;125    		   break;
0002c4  ea00000d          B        |L1.768|
                  |L1.712|
;;;126       case 5:
0002c8  e1a00000          MOV      r0,r0
;;;127    		   i=AD1DR5; // preia valoarea din reg de date canal 5
0002cc  e59f005c          LDR      r0,|L1.816|
0002d0  e5903024          LDR      r3,[r0,#0x24]
;;;128    		   break;
0002d4  ea000009          B        |L1.768|
                  |L1.728|
;;;129       case 6:
0002d8  e1a00000          MOV      r0,r0
;;;130    		   i=AD1DR6; // preia valoarea din reg de date canal 6
0002dc  e59f004c          LDR      r0,|L1.816|
0002e0  e5903028          LDR      r3,[r0,#0x28]
;;;131    		   break;
0002e4  ea000005          B        |L1.768|
                  |L1.744|
;;;132       case 7:
0002e8  e1a00000          MOV      r0,r0
;;;133    		   i=AD1DR7; // preia valoarea din reg de date canal 7
0002ec  e59f003c          LDR      r0,|L1.816|
0002f0  e590302c          LDR      r3,[r0,#0x2c]
;;;134    		   break;
0002f4  ea000001          B        |L1.768|
                  |L1.760|
;;;135       default:
0002f8  e1a00000          MOV      r0,r0
;;;136       		   break;
0002fc  e1a00000          MOV      r0,r0
                  |L1.768|
000300  e1a00000          MOV      r0,r0                 ;113
;;;137       } //end switch
;;;138       } 
;;;139       //asteapta final conversie(bit DONE=1 in reg global de date)
;;;140       while ((AD1GDR & 0x80000000) == 0);  
000304  e59f0024          LDR      r0,|L1.816|
000308  e5900004          LDR      r0,[r0,#4]
00030c  e3100102          TST      r0,#0x80000000
000310  0affffcd          BEQ      |L1.588|
;;;141       // izoleaza rezultatul si revine
;;;142       return ((i >> 6) & 0x03FF);		   
000314  e59f0010          LDR      r0,|L1.812|
000318  e0000323          AND      r0,r0,r3,LSR #6
00031c  e49de004          POP      {lr}
;;;143    }
000320  e12fff1e          BX       lr
;;;144    
                          ENDP

                  |L1.804|
000324  e002c000          DCD      0xe002c000
                  |L1.808|
000328  e0034000          DCD      0xe0034000
                  |L1.812|
00032c  000003ff          DCD      0x000003ff
                  |L1.816|
000330  e0060000          DCD      0xe0060000
