; generated by ARM/Thumb C/C++ Compiler with , RVCT3.1 [Build 939] for uVision
; commandline ArmCC [--debug -c --asm --interleave -oodometry.o --depend=odometry.d --device=DARMP --apcs=interwork -O0 -I"C:\Program Files\Keil\ARM\INC\Philips" --omf_browse=odometry.crf odometry.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  bytes2int PROC
;;;56     /* Functie de conversie a doi octeti in int */
;;;57     int bytes2int(unsigned char ch1, unsigned char ch2){
000000  e1a02000          MOV      r2,r0
;;;58        unsigned int val;
;;;59        ch1=ch1&0x0F;
000004  e202200f          AND      r2,r2,#0xf
;;;60        ch2=ch2&0x0F;
000008  e201100f          AND      r1,r1,#0xf
;;;61        val=ch1*10+ch2;;
00000c  e0823102          ADD      r3,r2,r2,LSL #2
000010  e0810083          ADD      r0,r1,r3,LSL #1
;;;62        return(val);
;;;63     }
000014  e12fff1e          BX       lr
;;;64     
                          ENDP

                  get_longitude_seconds PROC
;;;115    
;;;116    void get_longitude_seconds(void){
000018  e92d4030          PUSH     {r4,r5,lr}
00001c  e24dd01c          SUB      sp,sp,#0x1c
;;;117    	int seconds;
;;;118    	int decimals;
;;;119    
;;;120    	seconds=bytes2int(rxbuf[27],rxbuf[28]);
000020  e59f2220          LDR      r2,|L1.584|
000024  e5d2101c          LDRB     r1,[r2,#0x1c]  ; rxbuf
000028  e5d2001b          LDRB     r0,[r2,#0x1b]  ; rxbuf
00002c  ebfffffe          BL       bytes2int
000030  e1a04000          MOV      r4,r0
;;;121    	decimals=bytes2int(rxbuf[29],rxbuf[30]);
000034  e59f220c          LDR      r2,|L1.584|
000038  e5d2101e          LDRB     r1,[r2,#0x1e]  ; rxbuf
00003c  e5d2001d          LDRB     r0,[r2,#0x1d]  ; rxbuf
000040  ebfffffe          BL       bytes2int
000044  e1a05000          MOV      r5,r0
;;;122    	longitude_seconds=(double)seconds+(double)decimals/100.0;
000048  e1a00005          MOV      r0,r5
00004c  ebfffffe          BL       __aeabi_i2d
000050  e28d2010          ADD      r2,sp,#0x10
000054  e8820003          STM      r2,{r0,r1}
000058  e28f0f7b          ADR      r0,|L1.588|
00005c  e890000c          LDM      r0,{r2,r3}
000060  e59d0010          LDR      r0,[sp,#0x10]
000064  ebfffffe          BL       __aeabi_ddiv
000068  e28d2008          ADD      r2,sp,#8
00006c  e8820003          STM      r2,{r0,r1}
000070  e1a00004          MOV      r0,r4
000074  ebfffffe          BL       __aeabi_i2d
000078  e88d0003          STM      sp,{r0,r1}
00007c  e28d3008          ADD      r3,sp,#8
000080  e893000c          LDM      r3,{r2,r3}
000084  ebfffffe          BL       __aeabi_dadd
000088  e59f21c4          LDR      r2,|L1.596|
00008c  e8820003          STM      r2,{r0,r1}  ; longitude_seconds, longitude_seconds
;;;123    }
000090  e28dd01c          ADD      sp,sp,#0x1c
000094  e8bd4030          POP      {r4,r5,lr}
000098  e12fff1e          BX       lr
;;;124    
                          ENDP

                  get_longitude_minutes PROC
;;;111    
;;;112    void get_longitude_minutes(void){
00009c  e52de004          PUSH     {lr}
;;;113    	longitude_minutes=bytes2int(rxbuf[24],rxbuf[25]);
0000a0  e59f21a0          LDR      r2,|L1.584|
0000a4  e5d21019          LDRB     r1,[r2,#0x19]  ; rxbuf
0000a8  e5d20018          LDRB     r0,[r2,#0x18]  ; rxbuf
0000ac  ebfffffe          BL       bytes2int
0000b0  e59f11a0          LDR      r1,|L1.600|
0000b4  e5810000          STR      r0,[r1,#0]  ; longitude_minutes
;;;114    }
0000b8  e49de004          POP      {lr}
0000bc  e12fff1e          BX       lr
;;;115    
                          ENDP

                  get_longitude_degrees PROC
;;;106    /* Functii de extragere a informatiei de longitudine din pachetele GPS */
;;;107    void get_longitude_degrees(void){
0000c0  e52de004          PUSH     {lr}
;;;108    	longitude_degrees=bytes2int(rxbuf[22],rxbuf[23]);
0000c4  e59f217c          LDR      r2,|L1.584|
0000c8  e5d21017          LDRB     r1,[r2,#0x17]  ; rxbuf
0000cc  e5d20016          LDRB     r0,[r2,#0x16]  ; rxbuf
0000d0  ebfffffe          BL       bytes2int
0000d4  e59f1180          LDR      r1,|L1.604|
0000d8  e5810000          STR      r0,[r1,#0]  ; longitude_degrees
;;;109    	if(rxbuf[21]=='1') longitude_degrees=longitude_degrees+100;
0000dc  e59f0164          LDR      r0,|L1.584|
0000e0  e5d00015          LDRB     r0,[r0,#0x15]  ; rxbuf
0000e4  e3500031          CMP      r0,#0x31
0000e8  1a000004          BNE      |L1.256|
0000ec  e59f0168          LDR      r0,|L1.604|
0000f0  e5900000          LDR      r0,[r0,#0]  ; longitude_degrees
0000f4  e2800064          ADD      r0,r0,#0x64
0000f8  e59f115c          LDR      r1,|L1.604|
0000fc  e5810000          STR      r0,[r1,#0]  ; longitude_degrees
                  |L1.256|
;;;110    }
000100  e49de004          POP      {lr}
000104  e12fff1e          BX       lr
;;;111    
                          ENDP

                  get_latitude_seconds PROC
;;;95     
;;;96     void get_latitude_seconds(void){
000108  e92d4030          PUSH     {r4,r5,lr}
00010c  e24dd01c          SUB      sp,sp,#0x1c
;;;97     	int seconds;
;;;98     	int decimals;
;;;99     	
;;;100    	seconds=bytes2int(rxbuf[12],rxbuf[13]);
000110  e59f2130          LDR      r2,|L1.584|
000114  e5d2100d          LDRB     r1,[r2,#0xd]  ; rxbuf
000118  e5d2000c          LDRB     r0,[r2,#0xc]  ; rxbuf
00011c  ebfffffe          BL       bytes2int
000120  e1a04000          MOV      r4,r0
;;;101    	decimals=bytes2int(rxbuf[14],rxbuf[15]);
000124  e59f211c          LDR      r2,|L1.584|
000128  e5d2100f          LDRB     r1,[r2,#0xf]  ; rxbuf
00012c  e5d2000e          LDRB     r0,[r2,#0xe]  ; rxbuf
000130  ebfffffe          BL       bytes2int
000134  e1a05000          MOV      r5,r0
;;;102    	latitude_seconds=(double)seconds+(double)decimals/100.0;
000138  e1a00005          MOV      r0,r5
00013c  ebfffffe          BL       __aeabi_i2d
000140  e28d2010          ADD      r2,sp,#0x10
000144  e8820003          STM      r2,{r0,r1}
000148  e28f00fc          ADR      r0,|L1.588|
00014c  e890000c          LDM      r0,{r2,r3}
000150  e59d0010          LDR      r0,[sp,#0x10]
000154  ebfffffe          BL       __aeabi_ddiv
000158  e28d2008          ADD      r2,sp,#8
00015c  e8820003          STM      r2,{r0,r1}
000160  e1a00004          MOV      r0,r4
000164  ebfffffe          BL       __aeabi_i2d
000168  e88d0003          STM      sp,{r0,r1}
00016c  e28d3008          ADD      r3,sp,#8
000170  e893000c          LDM      r3,{r2,r3}
000174  ebfffffe          BL       __aeabi_dadd
000178  e59f20e0          LDR      r2,|L1.608|
00017c  e8820003          STM      r2,{r0,r1}  ; latitude_seconds, latitude_seconds
;;;103    }
000180  e28dd01c          ADD      sp,sp,#0x1c
000184  e8bd4030          POP      {r4,r5,lr}
000188  e12fff1e          BX       lr
;;;104    
                          ENDP

                  get_latitude_minutes PROC
;;;91     
;;;92     void get_latitude_minutes(void){
00018c  e52de004          PUSH     {lr}
;;;93     	latitude_minutes=bytes2int(rxbuf[9],rxbuf[10]);
000190  e59f20b0          LDR      r2,|L1.584|
000194  e5d2100a          LDRB     r1,[r2,#0xa]  ; rxbuf
000198  e5d20009          LDRB     r0,[r2,#9]  ; rxbuf
00019c  ebfffffe          BL       bytes2int
0001a0  e59f10bc          LDR      r1,|L1.612|
0001a4  e5810000          STR      r0,[r1,#0]  ; latitude_minutes
;;;94     }
0001a8  e49de004          POP      {lr}
0001ac  e12fff1e          BX       lr
;;;95     
                          ENDP

                  get_latitude_degrees PROC
;;;87     /* Functii de extragere a informatiei de latitudine din pachetele GPS */ 
;;;88     void get_latitude_degrees(void){
0001b0  e52de004          PUSH     {lr}
;;;89     	latitude_degrees=bytes2int(rxbuf[7],rxbuf[8]);
0001b4  e59f208c          LDR      r2,|L1.584|
0001b8  e5d21008          LDRB     r1,[r2,#8]  ; rxbuf
0001bc  e5d20007          LDRB     r0,[r2,#7]  ; rxbuf
0001c0  ebfffffe          BL       bytes2int
0001c4  e59f109c          LDR      r1,|L1.616|
0001c8  e5810000          STR      r0,[r1,#0]  ; latitude_degrees
;;;90     }
0001cc  e49de004          POP      {lr}
0001d0  e12fff1e          BX       lr
;;;91     
                          ENDP

                  compare_strings PROC
;;;74     /* Functie de comparare a doua stringuri util in filtrarea pachetelor receptionate */
;;;75     int compare_strings(unsigned char buffer1[], unsigned char buffer2[]){
0001d4  e1a02000          MOV      r2,r0
;;;76       int i;
;;;77       i=0;
0001d8  e3a03000          MOV      r3,#0
;;;78       while(buffer1[i]!=0)
0001dc  ea000006          B        |L1.508|
                  |L1.480|
;;;79         {
;;;80         if(buffer1[i]!=buffer2[i]) return(0);
0001e0  e7d20003          LDRB     r0,[r2,r3]
0001e4  e7d1c003          LDRB     r12,[r1,r3]
0001e8  e150000c          CMP      r0,r12
0001ec  0a000001          BEQ      |L1.504|
0001f0  e3a00000          MOV      r0,#0
                  |L1.500|
;;;81         else i++;
;;;82         }
;;;83       return(1);
;;;84     }
0001f4  e12fff1e          BX       lr
                  |L1.504|
0001f8  e2833001          ADD      r3,r3,#1              ;81
                  |L1.508|
0001fc  e7d20003          LDRB     r0,[r2,r3]            ;78
000200  e3500000          CMP      r0,#0                 ;78
000204  1afffff5          BNE      |L1.480|
000208  e3a00001          MOV      r0,#1                 ;83
00020c  eafffff8          B        |L1.500|
;;;85     
                          ENDP

                  get_gps_packet_name PROC
;;;68       int i;
;;;69       for(i=1;i<6;i++) packet_name[i-1] = rxbuf[i];
000210  e3a00001          MOV      r0,#1
000214  ea000005          B        |L1.560|
                  |L1.536|
000218  e59f1028          LDR      r1,|L1.584|
00021c  e7d11000          LDRB     r1,[r1,r0]
000220  e2402001          SUB      r2,r0,#1
000224  e59f3040          LDR      r3,|L1.620|
000228  e7c31002          STRB     r1,[r3,r2]
00022c  e2800001          ADD      r0,r0,#1
                  |L1.560|
000230  e3500006          CMP      r0,#6
000234  bafffff7          BLT      |L1.536|
;;;70       packet_name[i]=0;
000238  e3a01000          MOV      r1,#0
00023c  e59f2028          LDR      r2,|L1.620|
000240  e7c21000          STRB     r1,[r2,r0]
;;;71     }
000244  e12fff1e          BX       lr
                  |L1.584|
000248  00000000          DCD      rxbuf
                  |L1.588|
00024c  00000000
000250  40590000          DCFD     0x4059000000000000 ; 100
                  |L1.596|
000254  00000000          DCD      longitude_seconds
                  |L1.600|
000258  00000000          DCD      longitude_minutes
                  |L1.604|
00025c  00000000          DCD      longitude_degrees
                  |L1.608|
000260  00000000          DCD      latitude_seconds
                  |L1.612|
000264  00000000          DCD      latitude_minutes
                  |L1.616|
000268  00000000          DCD      latitude_degrees
                  |L1.620|
00026c  00000000          DCD      packet_name
                          ENDP

                  parse_gps_packet PROC
;;;37     /* Functie care parseaza pachetele GPS (NMEA) receptionate */
;;;38     int parse_gps_packet(void){
000270  e92d4010          PUSH     {r4,lr}
;;;39       int a;
;;;40       get_gps_packet_name();
000274  ebfffffe          BL       get_gps_packet_name
;;;41       a=compare_strings(packet_name, name1);
000278  e59f1250          LDR      r1,|L1.1232|
00027c  e51f0018          LDR      r0,|L1.620|
000280  ebfffffe          BL       compare_strings
000284  e1a04000          MOV      r4,r0
;;;42         if(a==1)
000288  e3540001          CMP      r4,#1
00028c  1a000008          BNE      |L1.692|
;;;43         {
;;;44         get_latitude_degrees();
000290  ebfffffe          BL       get_latitude_degrees
;;;45         get_latitude_minutes();
000294  ebfffffe          BL       get_latitude_minutes
;;;46         get_latitude_seconds();
000298  ebfffffe          BL       get_latitude_seconds
;;;47         get_longitude_degrees();
00029c  ebfffffe          BL       get_longitude_degrees
;;;48         get_longitude_minutes();
0002a0  ebfffffe          BL       get_longitude_minutes
;;;49         get_longitude_seconds();
0002a4  ebfffffe          BL       get_longitude_seconds
;;;50         return(1);
0002a8  e3a00001          MOV      r0,#1
                  |L1.684|
0002ac  e8bd4010          POP      {r4,lr}
;;;51         }
;;;52       else return(0);
;;;53     }
0002b0  e12fff1e          BX       lr
                  |L1.692|
0002b4  e3a00000          MOV      r0,#0                 ;52
0002b8  eafffffb          B        |L1.684|
;;;54     
                          ENDP

                  convert_lat PROC
;;;127    /* Conversie din informatia de latitudine */
;;;128    long convert_lat(void){
0002bc  e92d4010          PUSH     {r4,lr}
0002c0  e24dd020          SUB      sp,sp,#0x20
;;;129       double temp;
;;;130       long i;
;;;131    
;;;132       temp=latitude_degrees*111132+(double)latitude_minutes*(111132.0/60.0);
0002c4  e51f0068          LDR      r0,|L1.612|
0002c8  e5900000          LDR      r0,[r0,#0]  ; latitude_minutes
0002cc  ebfffffe          BL       __aeabi_i2d
0002d0  e28d2010          ADD      r2,sp,#0x10
0002d4  e8820003          STM      r2,{r0,r1}
0002d8  e28f0f7d          ADR      r0,|L1.1236|
0002dc  e890000c          LDM      r0,{r2,r3}
0002e0  e59d0010          LDR      r0,[sp,#0x10]
0002e4  ebfffffe          BL       __aeabi_dmul
0002e8  e28d2008          ADD      r2,sp,#8
0002ec  e8820003          STM      r2,{r0,r1}
0002f0  e51f1090          LDR      r1,|L1.616|
0002f4  e5911000          LDR      r1,[r1,#0]  ; latitude_degrees
0002f8  e59f21dc          LDR      r2,|L1.1244|
0002fc  e0000291          MUL      r0,r1,r2
000300  ebfffffe          BL       __aeabi_i2d
000304  e88d0003          STM      sp,{r0,r1}
000308  e28d3008          ADD      r3,sp,#8
00030c  e893000c          LDM      r3,{r2,r3}
000310  ebfffffe          BL       __aeabi_dadd
000314  e28d2018          ADD      r2,sp,#0x18
000318  e8820003          STM      r2,{r0,r1}
;;;133       temp=temp+latitude_seconds*(111132.0/3600.0);
00031c  e28f0f6f          ADR      r0,|L1.1248|
000320  e890000c          LDM      r0,{r2,r3}
000324  e51f00cc          LDR      r0,|L1.608|
000328  e8900003          LDM      r0,{r0,r1}  ; latitude_seconds, latitude_seconds
00032c  ebfffffe          BL       __aeabi_dmul
000330  e28d2010          ADD      r2,sp,#0x10
000334  e8820003          STM      r2,{r0,r1}
000338  e28d3018          ADD      r3,sp,#0x18
00033c  e893000c          LDM      r3,{r2,r3}
000340  ebfffffe          BL       __aeabi_dadd
000344  e28d2018          ADD      r2,sp,#0x18
000348  e8820003          STM      r2,{r0,r1}
;;;134       i=floor(temp);
00034c  e28d1018          ADD      r1,sp,#0x18
000350  e8910003          LDM      r1,{r0,r1}
000354  ebfffffe          BL       floor
000358  e28d2010          ADD      r2,sp,#0x10
00035c  e8820003          STM      r2,{r0,r1}
000360  ebfffffe          BL       __aeabi_d2iz
000364  e1a04000          MOV      r4,r0
;;;135       return(i);
000368  e1a00004          MOV      r0,r4
00036c  e28dd020          ADD      sp,sp,#0x20
000370  e8bd4010          POP      {r4,lr}
;;;136    }
000374  e12fff1e          BX       lr
;;;137    
                          ENDP

                  convert_long PROC
;;;139    /* Conversie din informatia de longitudine */
;;;140    long convert_long(void){
000378  e92d4010          PUSH     {r4,lr}
00037c  e24dd020          SUB      sp,sp,#0x20
;;;141       double temp;
;;;142       long i;
;;;143    
;;;144       temp=longitude_degrees*78847+(double)longitude_minutes*(78847.0/60.0);
000380  e51f0130          LDR      r0,|L1.600|
000384  e5900000          LDR      r0,[r0,#0]  ; longitude_minutes
000388  ebfffffe          BL       __aeabi_i2d
00038c  e28d2010          ADD      r2,sp,#0x10
000390  e8820003          STM      r2,{r0,r1}
000394  e28f0f53          ADR      r0,|L1.1256|
000398  e890000c          LDM      r0,{r2,r3}
00039c  e59d0010          LDR      r0,[sp,#0x10]
0003a0  ebfffffe          BL       __aeabi_dmul
0003a4  e28d2008          ADD      r2,sp,#8
0003a8  e8820003          STM      r2,{r0,r1}
0003ac  e51f1158          LDR      r1,|L1.604|
0003b0  e5911000          LDR      r1,[r1,#0]  ; longitude_degrees
0003b4  e59f2134          LDR      r2,|L1.1264|
0003b8  e0000291          MUL      r0,r1,r2
0003bc  ebfffffe          BL       __aeabi_i2d
0003c0  e88d0003          STM      sp,{r0,r1}
0003c4  e28d3008          ADD      r3,sp,#8
0003c8  e893000c          LDM      r3,{r2,r3}
0003cc  ebfffffe          BL       __aeabi_dadd
0003d0  e28d2018          ADD      r2,sp,#0x18
0003d4  e8820003          STM      r2,{r0,r1}
;;;145       temp=temp+longitude_seconds*(78847.0/3600.0);
0003d8  e28f0f45          ADR      r0,|L1.1268|
0003dc  e890000c          LDM      r0,{r2,r3}
0003e0  e51f0194          LDR      r0,|L1.596|
0003e4  e8900003          LDM      r0,{r0,r1}  ; longitude_seconds, longitude_seconds
0003e8  ebfffffe          BL       __aeabi_dmul
0003ec  e28d2010          ADD      r2,sp,#0x10
0003f0  e8820003          STM      r2,{r0,r1}
0003f4  e28d3018          ADD      r3,sp,#0x18
0003f8  e893000c          LDM      r3,{r2,r3}
0003fc  ebfffffe          BL       __aeabi_dadd
000400  e28d2018          ADD      r2,sp,#0x18
000404  e8820003          STM      r2,{r0,r1}
;;;146       i=floor(temp);
000408  e28d1018          ADD      r1,sp,#0x18
00040c  e8910003          LDM      r1,{r0,r1}
000410  ebfffffe          BL       floor
000414  e28d2010          ADD      r2,sp,#0x10
000418  e8820003          STM      r2,{r0,r1}
00041c  ebfffffe          BL       __aeabi_d2iz
000420  e1a04000          MOV      r4,r0
;;;147       return(i);
000424  e1a00004          MOV      r0,r4
000428  e28dd020          ADD      sp,sp,#0x20
00042c  e8bd4010          POP      {r4,lr}
;;;148    }
000430  e12fff1e          BX       lr
;;;149    
                          ENDP

                  save_origin PROC
;;;151    /* Functie care seteaza o pozitie de referinta pentru miscarea in plan */
;;;152    void save_origin(void){
000434  e92d4010          PUSH     {r4,lr}
;;;153       x_origin=convert_long();
000438  ebfffffe          BL       convert_long
00043c  e59f10b8          LDR      r1,|L1.1276|
000440  e5810000          STR      r0,[r1,#0]  ; x_origin
;;;154       y_origin=convert_lat();
000444  ebfffffe          BL       convert_lat
000448  e59f10b0          LDR      r1,|L1.1280|
00044c  e5810000          STR      r0,[r1,#0]  ; y_origin
;;;155    }
000450  e8bd4010          POP      {r4,lr}
000454  e12fff1e          BX       lr
;;;156    
                          ENDP

                  get_x_position PROC
;;;157    /* Functii care returneaza pozitia in plan */
;;;158    long get_x_position(void){
000458  e92d4010          PUSH     {r4,lr}
;;;159     		 current_x=convert_long();
00045c  ebfffffe          BL       convert_long
000460  e59f109c          LDR      r1,|L1.1284|
000464  e5810000          STR      r0,[r1,#0]  ; current_x
;;;160    		 current_x=current_x-x_origin;
000468  e2810000          ADD      r0,r1,#0
00046c  e5900000          LDR      r0,[r0,#0]  ; current_x
000470  e59f1084          LDR      r1,|L1.1276|
000474  e5911000          LDR      r1,[r1,#0]  ; x_origin
000478  e0400001          SUB      r0,r0,r1
00047c  e59f1080          LDR      r1,|L1.1284|
000480  e5810000          STR      r0,[r1,#0]  ; current_x
;;;161    	 return current_x;
000484  e2810000          ADD      r0,r1,#0
000488  e5900000          LDR      r0,[r0,#0]  ; current_x
00048c  e8bd4010          POP      {r4,lr}
;;;162    }
000490  e12fff1e          BX       lr
;;;163    
                          ENDP

                  get_y_position PROC
;;;164    long get_y_position(void){
000494  e92d4010          PUSH     {r4,lr}
;;;165     		 current_y=convert_lat();
000498  ebfffffe          BL       convert_lat
00049c  e59f1064          LDR      r1,|L1.1288|
0004a0  e5810000          STR      r0,[r1,#0]  ; current_y
;;;166    		 current_y=current_y-y_origin;
0004a4  e2810000          ADD      r0,r1,#0
0004a8  e5900000          LDR      r0,[r0,#0]  ; current_y
0004ac  e59f104c          LDR      r1,|L1.1280|
0004b0  e5911000          LDR      r1,[r1,#0]  ; y_origin
0004b4  e0400001          SUB      r0,r0,r1
0004b8  e59f1048          LDR      r1,|L1.1288|
0004bc  e5810000          STR      r0,[r1,#0]  ; current_y
;;;167    	 return current_y;
0004c0  e2810000          ADD      r0,r1,#0
0004c4  e5900000          LDR      r0,[r0,#0]  ; current_y
0004c8  e8bd4010          POP      {r4,lr}
;;;168    }
0004cc  e12fff1e          BX       lr
                  |L1.1232|
0004d0  00000000          DCD      name1
                  |L1.1236|
0004d4  cccccccd
0004d8  409cf0cc          DCFD     0x409cf0cccccccccd ; 1852.2
                  |L1.1244|
0004dc  0001b21c          DCD      0x0001b21c
                  |L1.1248|
0004e0  51eb851f
0004e4  403edeb8          DCFD     0x403edeb851eb851f ; 30.870000000000001
                  |L1.1256|
0004e8  77777777
0004ec  40948877          DCFD     0x4094887777777777 ; 1314.1166666666666
                  |L1.1264|
0004f0  000133ff          DCD      0x000133ff
                  |L1.1268|
0004f4  d4c3b2a2
0004f8  4035e6e5          DCFD     0x4035e6e5d4c3b2a2 ; 21.901944444444446
                  |L1.1276|
0004fc  00000000          DCD      x_origin
                  |L1.1280|
000500  00000000          DCD      y_origin
                  |L1.1284|
000504  00000000          DCD      current_x
                  |L1.1288|
000508  00000000          DCD      current_y
                          ENDP

                  itoa PROC
;;;170    /* Functie de conversie int -> char */
;;;171    void itoa(int n, char *s) { 
00050c  e92d41f0          PUSH     {r4-r8,lr}
000510  e1a04000          MOV      r4,r0
000514  e1a05001          MOV      r5,r1
;;;172    char i;
;;;173    int n1;
;;;174    	if (n<0) {
000518  e3540000          CMP      r4,#0
00051c  aa000002          BGE      |L1.1324|
;;;175    	    n=-n;
000520  e2644000          RSB      r4,r4,#0
;;;176    	    *s++='-';
000524  e3a0002d          MOV      r0,#0x2d
000528  e4c50001          STRB     r0,[r5],#1
                  |L1.1324|
;;;177    		}
;;;178    	do
00052c  e1a00000          MOV      r0,r0
                  |L1.1328|
;;;179    	{ n1=n;
000530  e1a07004          MOV      r7,r4
;;;180    	  i=0;
000534  e3a06000          MOV      r6,#0
;;;181    	while(1) {
000538  ea00000a          B        |L1.1384|
                  |L1.1340|
;;;182    	  if (n1<=9){
00053c  e3570009          CMP      r7,#9
000540  ca000002          BGT      |L1.1360|
;;;183    	    *s++=n1+'0';
000544  e2870030          ADD      r0,r7,#0x30
000548  e4c50001          STRB     r0,[r5],#1
;;;184    	    break;
00054c  ea000006          B        |L1.1388|
                  |L1.1360|
;;;185    	  }	
;;;186    	  n1=n1/10;
000550  e3a0100a          MOV      r1,#0xa
000554  e1a00007          MOV      r0,r7
000558  ebfffffe          BL       __aeabi_idivmod
00055c  e1a07000          MOV      r7,r0
;;;187    	  i++;}
000560  e2860001          ADD      r0,r6,#1
000564  e20060ff          AND      r6,r0,#0xff
                  |L1.1384|
000568  eafffff3          B        |L1.1340|
                  |L1.1388|
00056c  e1a00000          MOV      r0,r0                 ;184
;;;188    	while(i){
000570  ea000003          B        |L1.1412|
                  |L1.1396|
;;;189    	  i--;
000574  e2460001          SUB      r0,r6,#1
000578  e20060ff          AND      r6,r0,#0xff
;;;190    	  n1=n1*10;}
00057c  e3a0000a          MOV      r0,#0xa
000580  e0070790          MUL      r7,r0,r7
                  |L1.1412|
000584  e3560000          CMP      r6,#0                 ;188
000588  1afffff9          BNE      |L1.1396|
;;;191    	  n-=n1;
00058c  e0444007          SUB      r4,r4,r7
;;;192    	}while (n);
000590  e3540000          CMP      r4,#0
000594  1affffe5          BNE      |L1.1328|
;;;193    	  *s++=0;
000598  e3a00000          MOV      r0,#0
00059c  e4c50001          STRB     r0,[r5],#1
;;;194    }
0005a0  e8bd41f0          POP      {r4-r8,lr}
0005a4  e12fff1e          BX       lr
;;;195    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=3

                  name1
000000  4750474c          DCB      0x47,0x50,0x47,0x4c
000004  4c00              DCB      0x4c,0x00
                  rxdata
000006  0000              DCB      0x00,0x00
                  idx
000008  00000000          DCD      0x00000000
                  idxsav
00000c  00000000          DCD      0x00000000
                  rbfull
000010  00000000          DCD      0x00000000
                  packet_name
000014  00000000          DCD      0x00000000
000018  00000000          DCB      0x00,0x00,0x00,0x00
                  latitude_degrees
00001c  00000000          DCD      0x00000000
                  latitude_minutes
000020  00000000          DCD      0x00000000
000024  00000000          DCD      0x00000000
                  latitude_seconds
                          %        8
                  longitude_degrees
000030  00000000          DCD      0x00000000
                  longitude_minutes
000034  00000000          DCD      0x00000000
                  longitude_seconds
                          %        8
                  x_origin
000040  00000000          DCD      0x00000000
                  y_origin
000044  00000000          DCD      0x00000000
                  current_x
000048  00000000          DCD      0x00000000
                  current_y
00004c  00000000          DCD      0x00000000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  rxbuf
                          %        256
                  txbuf
                          %        256
