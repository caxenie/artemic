; generated by ARM/Thumb C/C++ Compiler with , RVCT3.1 [Build 939] for uVision
; commandline ArmCC [--debug -c --asm --interleave -osonar_interface.o --depend=sonar_interface.d --device=DARMP --apcs=interwork -O0 -I"C:\Program Files\Keil\ARM\INC\Philips" --omf_browse=sonar_interface.crf sonar_interface.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  read_sonar PROC
;;;33     /*Functie de citire a ADC conectate la sonare */
;;;34     unsigned int read_sonar(int sonar){
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  e1a04000          MOV      r4,r0
;;;35     	/* valoarea tensiunii de la iesirea sonarului */
;;;36      	unsigned int val;	
;;;37     	/* citeste valoarea corespunzatoare sonarului */
;;;38     	switch(sonar){						   
000008  e3540006          CMP      r4,#6
00000c  308ff104          ADDCC    pc,pc,r4,LSL #2
000010  ea00001e          B        |L1.144|
000014  ea00001d          B        |L1.144|
000018  ea000003          B        |L1.44|
00001c  ea000007          B        |L1.64|
000020  ea00000b          B        |L1.84|
000024  ea00000f          B        |L1.104|
000028  ea000013          B        |L1.124|
                  |L1.44|
;;;39     	 		case 1: val = read_adc1(3);
00002c  e1a00000          MOV      r0,r0
000030  e3a00003          MOV      r0,#3
000034  ebfffffe          BL       read_adc1
000038  e1a05000          MOV      r5,r0
;;;40     					break;
00003c  ea000013          B        |L1.144|
                  |L1.64|
;;;41     			case 2: val = read_adc1(4);
000040  e1a00000          MOV      r0,r0
000044  e3a00004          MOV      r0,#4
000048  ebfffffe          BL       read_adc1
00004c  e1a05000          MOV      r5,r0
;;;42     					break;
000050  ea00000e          B        |L1.144|
                  |L1.84|
;;;43     			case 3: val = read_adc1(6);
000054  e1a00000          MOV      r0,r0
000058  e3a00006          MOV      r0,#6
00005c  ebfffffe          BL       read_adc1
000060  e1a05000          MOV      r5,r0
;;;44     					break;
000064  ea000009          B        |L1.144|
                  |L1.104|
;;;45     			case 4: val = read_adc1(7);
000068  e1a00000          MOV      r0,r0
00006c  e3a00007          MOV      r0,#7
000070  ebfffffe          BL       read_adc1
000074  e1a05000          MOV      r5,r0
;;;46     					break;
000078  ea000004          B        |L1.144|
                  |L1.124|
;;;47     			case 5: val = read_adc0(1);
00007c  e1a00000          MOV      r0,r0
000080  e3a00001          MOV      r0,#1
000084  ebfffffe          BL       read_adc0
000088  e1a05000          MOV      r5,r0
;;;48     					break;
00008c  e1a00000          MOV      r0,r0
                  |L1.144|
000090  e1a00000          MOV      r0,r0                 ;40
;;;49     	}
;;;50     	/* returneaza distanta in cm pana la primul obstacol */
;;;51     	return (unsigned int)(((val*3300)/1024)/SCALE);
000094  e59f1134          LDR      r1,|L1.464|
000098  e0010195          MUL      r1,r5,r1
00009c  e1a00521          LSR      r0,r1,#10
0000a0  ebfffffe          BL       __aeabi_ui2f
0000a4  e1a07000          MOV      r7,r0
0000a8  e59f1124          LDR      r1,|L1.468|
0000ac  ebfffffe          BL       __aeabi_fdiv
0000b0  e1a06000          MOV      r6,r0
0000b4  ebfffffe          BL       __aeabi_f2uiz
0000b8  e8bd41f0          POP      {r4-r8,lr}
;;;52     }
0000bc  e12fff1e          BX       lr
;;;53     
                          ENDP

                  delay_us PROC
;;;80        int a,b;
;;;81        for(a=0;a<x;a++)
0000c0  e3a01000          MOV      r1,#0
0000c4  ea000005          B        |L1.224|
                  |L1.200|
;;;82           for(b=0;b<4;b++);
0000c8  e3a02000          MOV      r2,#0
0000cc  ea000000          B        |L1.212|
                  |L1.208|
0000d0  e2822001          ADD      r2,r2,#1
                  |L1.212|
0000d4  e3520004          CMP      r2,#4
0000d8  bafffffc          BLT      |L1.208|
0000dc  e2811001          ADD      r1,r1,#1              ;81
                  |L1.224|
0000e0  e1510000          CMP      r1,r0                 ;81
0000e4  bafffff7          BLT      |L1.200|
;;;83     }
0000e8  e12fff1e          BX       lr
;;;84     
                          ENDP

                  enable_sonar_chain PROC
;;;56     */
;;;57     void enable_sonar_chain(void){
0000ec  e52de004          PUSH     {lr}
;;;58     	  // seteaza pinii pentru BW (bandwidth)
;;;59     	  IO1DIR |= ((1<<16) | (1<<17) | (1<<18) | (1<<19) | (1<<20) | (1<<21));
0000f0  e59f00e0          LDR      r0,|L1.472|
0000f4  e5900018          LDR      r0,[r0,#0x18]
0000f8  e380083f          ORR      r0,r0,#0x3f0000
0000fc  e59f10d4          LDR      r1,|L1.472|
000100  e5810018          STR      r0,[r1,#0x18]
;;;60     	  // BW este mentinut High (1)
;;;61     	  IO1SET |= ((1<<16) | (1<<17) | (1<<18) | (1<<19) | (1<<20));
000104  e1a00001          MOV      r0,r1
000108  e5900014          LDR      r0,[r0,#0x14]
00010c  e380081f          ORR      r0,r0,#0x1f0000
000110  e5810014          STR      r0,[r1,#0x14]
;;;62     	  // conecteaza RX la 1 logic pt 50 us
;;;63     	  IO1SET |= (1<<21);
000114  e1a00001          MOV      r0,r1
000118  e5900014          LDR      r0,[r0,#0x14]
00011c  e3800602          ORR      r0,r0,#0x200000
000120  e5810014          STR      r0,[r1,#0x14]
;;;64      	  delay_us(50);
000124  e3a00032          MOV      r0,#0x32
000128  ebfffffe          BL       delay_us
;;;65           IO1CLR |= (1<<21); 
00012c  e59f00a4          LDR      r0,|L1.472|
000130  e590001c          LDR      r0,[r0,#0x1c]
000134  e3800602          ORR      r0,r0,#0x200000
000138  e59f1098          LDR      r1,|L1.472|
00013c  e581001c          STR      r0,[r1,#0x1c]
;;;66     	  // comuta pinul RX in high-Z0
;;;67     	  IO1DIR &=~(1<<21);
000140  e1a00001          MOV      r0,r1
000144  e5900018          LDR      r0,[r0,#0x18]
000148  e3c00602          BIC      r0,r0,#0x200000
00014c  e5810018          STR      r0,[r1,#0x18]
;;;68     }
000150  e49de004          POP      {lr}
000154  e12fff1e          BX       lr
;;;69     
                          ENDP

                  sonar_strobe PROC
;;;70     /* Functie de strobe pentru activarea citirilor de la sonare */
;;;71     void sonar_strobe(void){
000158  e52de004          PUSH     {lr}
;;;72     	   IO1SET |= (1<<21);
00015c  e59f0074          LDR      r0,|L1.472|
000160  e5900014          LDR      r0,[r0,#0x14]
000164  e3800602          ORR      r0,r0,#0x200000
000168  e59f1068          LDR      r1,|L1.472|
00016c  e5810014          STR      r0,[r1,#0x14]
;;;73      	   delay_us(50);
000170  e3a00032          MOV      r0,#0x32
000174  ebfffffe          BL       delay_us
;;;74            IO1CLR |= (1<<21); 
000178  e59f0058          LDR      r0,|L1.472|
00017c  e590001c          LDR      r0,[r0,#0x1c]
000180  e3800602          ORR      r0,r0,#0x200000
000184  e59f104c          LDR      r1,|L1.472|
000188  e581001c          STR      r0,[r1,#0x1c]
;;;75     	   delay_us(50);
00018c  e3a00032          MOV      r0,#0x32
000190  ebfffffe          BL       delay_us
;;;76     }
000194  e49de004          POP      {lr}
000198  e12fff1e          BX       lr
;;;77     
                          ENDP

                  format_sonar_data_and_send PROC
;;;87      */
;;;88     void format_sonar_data_and_send(unsigned int data){
00019c  e92d4070          PUSH     {r4-r6,lr}
0001a0  e1a04000          MOV      r4,r0
;;;89     	// octeti ascii corespunzatori valorii citite
;;;90     	unsigned char data_l, data_h;
;;;91     	// se extrage octetul mai semnificativ al valorii
;;;92     	data_h = (data&0x300)>>8;
0001a4  e2040c03          AND      r0,r4,#0x300
0001a8  e1a06420          LSR      r6,r0,#8
;;;93     	// se extrage octetul mai putin semnificativ
;;;94     	data_l = data&0xff;
0001ac  e20450ff          AND      r5,r4,#0xff
;;;95     	// trimite octetii pe linia seriala dupa conversia ascii
;;;96     	uart0_send_ascii(data_h);
0001b0  e1a00006          MOV      r0,r6
0001b4  ebfffffe          BL       uart0_send_ascii
;;;97     	uart0_send_ascii(data_l);
0001b8  e1a00005          MOV      r0,r5
0001bc  ebfffffe          BL       uart0_send_ascii
;;;98     	// separator 
;;;99     	putchar_uart0(',');
0001c0  e3a0002c          MOV      r0,#0x2c
0001c4  ebfffffe          BL       putchar_uart0
;;;100    }
0001c8  e8bd4070          POP      {r4-r6,lr}
0001cc  e12fff1e          BX       lr
                          ENDP

                  |L1.464|
0001d0  00000ce4          DCD      0x00000ce4
                  |L1.468|
0001d4  40570a3d          DCD      0x40570a3d
                  |L1.472|
0001d8  e0028000          DCD      0xe0028000
